--- This file contains information about CockroachDB (CRDB) which I could record ----

-What features are difficult for application developers to implement with traditional SQL databases?
 - Availability
 - Scalability
   Explanation:
   Traditional SQL databases delivered ACID transactions and joins easily, but scalability and high availability were difficult to implement.
       --ACID transactions are database operations ensuring reliability and data integrity through four key properties: Atomicity (all-or-nothing), Consistency (valid data states), Isolation (concurrent operations don't interfere), and Durability (committed changes are permanent)
       When someone says ACID guarantees, they're talking about four promises.
          -First,  transaction has to be atomic, meaning that all parts of the transaction happen or none.
          -Second, they have to be consistent, which in this context means the transaction has to respect any rules imposed on the database like foreign key constraints, and move from one consistent state to another with no inconsistent states visible to any readers at any time.
          -Third, they have to be isolated, meaning that even though the database might be able to parallelize some operations, it can't permit it to look like they're interleaved.
          -Finally, they have to be durable.
           When a transaction is committed, it stays committed even in the face of node failure.
       --Joins are fundamental commands in database management (SQL) that combine rows from two or more tables based on related columns, creating a new, unified result set for querying data that spans multiple tables, like linking customers to their orders.

--- Distributed SQL, must comply with this set of characteristics:
 - Scale
 - Consistency
 - Resiliency
 - SQL (must use this language)

--- NoSQL vs Legacy SQL
                   Scale  query by SQL  Consistency  Resiliency
    NoSQL           Yes      No            No           Yes
    Legacy SQL      No       Yes           Yes          No

---What Cockroach Delivers:
   -ACID Transactions
   -PostgreSQL wire protocol
   -Geo-replication
   -Multi-cloud
   -Advanced admin tools
   -Optimization
   -Baked in security

-- These are some of the features of CRDB:
 - Transactions
 - Geo-replication
 - High availability
 - Scalability

-- CRDB uses serializable isolation level.

------Cluster Concepts ----
 - Basic Model of Cluster Data: Keyspace
 - Keyspace is divided into ranges, by default 64MB in size but on version 20.1 this default changed to 512MB
 - Ranges are units that CockroachDB replicates and distributes to the nodes of the cluster
 - Replicas = copies of ranges, up to a replication factor
 - Replication Factor = How many times a range is replicated in a cluster
 - Replicas distributed among nodes of cluster

------The Raft Protocol in CockroachDB ----
 - CockroachDB uses the Raft Protocol to perform writes in a distributed and durable manner.
 - Raft is an algorithm that allows a distributed set of servers to agree on any values without losing the record of that value, even in the face of node failure. CockroachDB uses it to perform all writes.

-Recall that CockroachDB organizes its data into a keyspace, divided into ranges and distributes replicas of each range throughout the cluster based on the replication factor.
 - For CockroachDB, each range defines a Raft group.
 - The cluster has seven ranges, so there will be seven raft groups.

-CockroachDB has a concept of something called a lease, which it assigns to one of these replicas called the leaseholder. Its job will be to serve reads on its own bypassing Raft but also keeping track of write commits, so it knows not to show rights until they're durable.
  1.- Let's put a lease on one of those replicas.
  2.- Now all reads and writes to the range will be sent to that node.

- Raft. The first thing to know about Raft is that 
  - replicas are either leaders or followers.
    - Leaders coordinate the distributed write process while followers assist.
      If a follower doesn't see a heartbeat from a leader, it'll get a randomized time-out, declare itself a candidate, and call for an election. Majority vote makes it a leader. The process takes seconds.
  3.- Let's elect a leader.
      I made the leader the same as the leaseholder, and while they're different roles, in practice, CockroachDB does a good job of keeping the lease with the leader for efficiency. So we'll assume that scenario.
  4.- Writes are kicked off by the leaseholders which tells the leader to begin the process.
  5.- Here's an insert.
  6.- The leader first upends the command to its Raft log, which is an ordered set of commands on disc.
  7.- The leader then proposes the write to the followers.
  8.- Each follower will replicate the command on its own Raft log.
I showed only one replication so far since that's enough for a majority. Even without hitting the third node, the write will persist through any single node failure.
  9.- Consensus has been achieved, but the leader doesn't know that yet. So the follower has to let it know.
 10.- At this point, the leader knows the Raft command was replicated so it can commit the write and notify the leaseholder to begin showing it to readers.
 11.- Eventually, that write will go to every replica.
Let's look at our full cluster with a leader for each range to get a big picture sense of things. Here, each range has one replica. That's its leader and its leaseholder. All sequel operations are routed to the appropriate leaseholders. Reads are returned while writes are passed to the leaders to start building consensus.
So, what have we learned? We've seen that the leaseholder ensures that readers only see committed writes, and that replicas arranged together form a Raft group that elects one leader.
We've seen how a distributed consensus is achieved for writes, and that's how Raft works in CockroachDB. 

 In a Raft group, how many copies of a Raft Log entry must exist for a write to be committed?
 Enough to be on a majority of the Raft group

 What happens when a single node goes down?
 Leaseholders, if present on a node, will move.

 
--Resiliency in Large Clusters --

 When can a cluster heal its way out of a fragile state (one with under-replicated ranges)?
 When it has enough nodes to up-replicate the under-replicated ranges


----------Getting a local single node cluster going----------------

 Command:
 $ cockroach start-single-node --insecure --listen-addr=localhost:26257 --http-addr=localhost:8080
   --> --insecure ==> no encryption or authentication, not for production!!
   --> --http-addr=localhost:8080 ==> where we can see the admin UI to get visibility into the cluster
   --> --listen-addr=localhost:26257 ==> where/what port the node should listen for connections
 
 ---To stop the cluster just hit Ctrl+c

    Another command that also works is:
    $ cockroach start-single-node --insecure --listen-addr localhost

    This give the exact same result as the previous but assumes default parameters for the ports by only 
    specifying "localhost"

-----------Use SQL Shell to create and modify Tables-------------

 > Connect to cluster using SQL shell:
 
   $ cockroach sql --insecure
    This connects to the cluster in the local host that was created

 > Some SQL commands that are usefull for manipulating and going through the cluster
   
   Example of how the prompt will look like inthe SQL shell:

         root@localhost:26257/defaultdb>
   
   This means you are logged in as root and connecting through the localhost on port 26257 
   and on the defaultdb database.

   >> SHOW DATABASES;  ---> Showw all the databases in the cluster
    Ex.

root@localhost:26257/defaultdb> SHOW DATABASES;                                             
  database_name | owner | primary_region | secondary_region | regions | survival_goal
----------------+-------+----------------+------------------+---------+----------------
  defaultdb     | root  | NULL           | NULL             | {}      | NULL
  postgres      | root  | NULL           | NULL             | {}      | NULL
  system        | node  | NULL           | NULL             | {}      | NULL
(3 rows)

Time: 6ms total (execution 5ms / network 0ms)


    
    >> CREATE DATABASE <database name>;  ---> create a new database 
    Ex.

root@localhost:26257/defaultdb> CREATE DATABASE crdb_uni;                                   
CREATE DATABASE

Time: 86ms total (execution 80ms / network 6ms)

root@localhost:26257/defaultdb> SHOW DATABASES;
  database_name | owner | primary_region | secondary_region | regions | survival_goal
----------------+-------+----------------+------------------+---------+----------------
  defaultdb     | root  | NULL           | NULL             | {}      | NULL
  postgres      | root  | NULL           | NULL             | {}      | NULL
  system        | node  | NULL           | NULL             | {}      | NULL
(3 rows)

Time: 6ms total (execution 5ms / network 0ms)



    >> CREATE DATABASE <database name>;  ---> create a new database
    Ex.

root@localhost:26257/defaultdb> CREATE DATABASE crdb_uni;
CREATE DATABASE

Time: 86ms total (execution 80ms / network 6ms)

root@localhost:26257/defaultdb> SHOW DATABASES;
  database_name | owner | primary_region | secondary_region | regions | survival_goal
----------------+-------+----------------+------------------+---------+----------------
  crdb_uni      | root  | NULL           | NULL             | {}      | NULL
  defaultdb     | root  | NULL           | NULL             | {}      | NULL
  postgres      | root  | NULL           | NULL             | {}      | NULL
  system        | node  | NULL           | NULL             | {}      | NULL
(4 rows)

   >> SET database = <database name>; ------> change into another database
   Ex.

root@localhost:26257/defaultdb> SET database = crdb_uni;                                    
SET

Time: 2ms total (execution 1ms / network 1ms)

root@localhost:26257/crdb_uni>        

   >> SHOW TABLES <database>; ------> This will show the tables in a spacific database
   Ex.

root@localhost:26257/defaultdb> SHOW TABLES FROM movr;
  schema_name |         table_name         | type  | owner | estimated_row_count | locality
--------------+----------------------------+-------+-------+---------------------+-----------
  public      | promo_codes                | table | root  |                1000 | NULL
  public      | rides                      | table | root  |                 500 | NULL
  public      | user_promo_codes           | table | root  |                   5 | NULL
  public      | users                      | table | root  |                  50 | NULL
  public      | vehicle_location_histories | table | root  |                1000 | NULL
  public      | vehicles                   | table | root  |                  15 | NULL
(6 rows)

Time: 38ms total (execution 38ms / network 0ms)

   >> SELECT * FROM <database.table> LIMIT 10; -------> This will show contents of a table limiting to 10 rows, the amount of rows can be set to any number
   Ex.
root@localhost:26257/defaultdb> SELECT * FROM movr.users LIMIT 10;
                   id                  |   city    |         name         |            address            | credit_card
---------------------------------------+-----------+----------------------+-------------------------------+--------------
  ae147ae1-47ae-4800-8000-000000000022 | amsterdam | Chad Sanchez         | 89287 Erica Inlet Apt. 93     |  3693084989
  b3333333-3333-4000-8000-000000000023 | amsterdam | Teresa Dougherty DVM | 99126 Lam Ridges Suite 50     |  5916323763
  b851eb85-1eb8-4000-8000-000000000024 | amsterdam | Christina Brown      | 80522 John Pass Suite 7       |  1532468377
  bd70a3d7-0a3d-4000-8000-000000000025 | amsterdam | Angel Gaines         | 15540 Keith Parks Suite 32    |  1747410307
  c28f5c28-f5c2-4000-8000-000000000026 | amsterdam | Tara Stewart         | 52035 Ronald Island Apt. 53   |  1730210281
  1eb851eb-851e-4800-8000-000000000006 | boston    | Teresa Scott         | 17644 Stephanie Manor Apt. 20 |  6948766915
  23d70a3d-70a3-4800-8000-000000000007 | boston    | Karen Mueller        | 11569 Jeremy Turnpike Apt. 57 |  3085984379
  28f5c28f-5c28-4600-8000-000000000008 | boston    | Andrew Stout         | 38714 Davis Path              |  4686866258
  2e147ae1-47ae-4400-8000-000000000009 | boston    | Jennifer Martinez    | 67021 Mary Extensions         |  3479985048
  33333333-3333-4400-8000-00000000000a | boston    | Teresa Washington    | 47989 David Station           |  0036139633
(10 rows)

Time: 4ms total (execution 3ms / network 1ms)


   >> CREATE TABLE students (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), name STRING);
      This creates a table with two columns id and name.
      The id column needs to have certain properties:
        - UUID. The values on the id column need to be the univarsally unique identifier data
          type,or UUID.
        - PRIMARY KEY. This column is the PRIMARY KEY for the table, which specifies the
          values must uniquely idenfy each row. The columns in the PRIMARY KEY constraint are
          used to create its primary index, which CockroachDB uses, by default, to access the
          table's data.
        - DEFAULT gen_random_uuid(). Specify that if the value is not provided for a row's ID,
          the default value is an an auto-generated random UUID.
      Ex.
root@localhost:26257/defaultdb> CREATE TABLE students (id UUID PRIMARY KEY DEFAULT gen_random_uuid(), name STRING);

CREATE TABLE

Time: 43ms total (execution 21ms / network 22ms)

     Note that this created the table in "defaultdb"

root@localhost:26257/defaultdb> SELECT * FROM defaultdb.students LIMIT 10;
  id | name
-----+-------
(0 rows)

Time: 3ms total (execution 2ms / network 1ms)

     Note that the table is empty at the moment.

   >> SHOW CREATE students;  ---> this shows the schema and properties of the table
      Ex.
root@localhost:26257/defaultdb> SHOW CREATE students;
  table_name |                 create_statement
-------------+----------------------------------------------------
  students   | CREATE TABLE public.students (
             |     id UUID NOT NULL DEFAULT gen_random_uuid(),
             |     name STRING NULL,
             |     CONSTRAINT students_pkey PRIMARY KEY (id ASC)
             | );
(1 row)

Time: 23ms total (execution 22ms / network 0ms)


   >> CREATE TABLE courses (sys_id UUID DEFAULT gen_random_uuid(), course_id INT, name STRING, PRIMARY KEY (sys_id, course_id));
      Ex.
root@localhost:26257/defaultdb> CREATE TABLE courses (sys_id UUID DEFAULT gen_random_uuid(), course_id INT, name STRING, PRIMARY KEY (sys_id, course_id));
CREATE TABLE

Time: 42ms total (execution 19ms / network 22ms)

root@localhost:26257/defaultdb> SHOW CREATE courses;
  table_name |                          create_statement
-------------+----------------------------------------------------------------------
  courses    | CREATE TABLE public.cousers (
             |     sys_id UUID NOT NULL DEFAULT gen_random_uuid(),
             |     course_id INT8 NOT NULL,
             |     name STRING NULL,
             |     CONSTRAINT cousers_pkey PRIMARY KEY (sys_id ASC, course_id ASC)
             | );
(1 row)

Time: 21ms total (execution 20ms / network 1ms)


    >> ALTER TABLE <table to alter> ADD COLUMN <name of new column> STRING; ----> this is to alter a table and in thid case adds a new column
       Ex.
root@localhost:26257/defaultdb> ALTER TABLE courses ADD COLUMN schedule STRING;
ALTER TABLE

Time: 368ms total (execution 367ms / network 1ms)

   >> SHOW CREATE TABLE <Table name>; -------> this will show the schema and properties of the table in question.
      Ex.
root@localhost:26257/defaultdb> SHOW CREATE TABLE courses;
  table_name |                          create_statement
-------------+----------------------------------------------------------------------
  courses    | CREATE TABLE public.courses (
             |     sys_id UUID NOT NULL DEFAULT gen_random_uuid(),
             |     course_id INT8 NOT NULL,
             |     name STRING NULL,
             |     schedule STRING NULL,
             |     CONSTRAINT courses_pkey PRIMARY KEY (sys_id ASC, course_id ASC)
             | );
(1 row)

Time: 15ms total (execution 15ms / network 0ms)

-----To spin up a multiple node cluster in local -----------

The command for fisrt node:
$ cockroach start --insecure --listen-addr=localhost:26257 --join=localhost:26257,localhost:26258,localhost:26259 --http-addr=localhost:8080 --store=cockroach-data-1 --background

Take note on the following:
--listen-addr=localhost:26257 -----> what port is this node going to use, each node will have its own port number
--join=localhost:26257,localhost:26258,localhost:26259   ---------> where is the node going to find the other nodes, if there are more nodes they will have to be added here
--http-addr=localhost:8080 ---------> port of the UI that the node is going to use to communicate to it. Each node will have its own port number.
--store=cockroach-data-1 ---------> directory where the node is going to keep its info on, each node will have it own directory. 
--background -----------> this makes the cluster to run in the background and we can use the terminal where we started the cluster.

Some of these port number are going t chenge to match the nodes that are going to be created.

Running the command will look like this:
Ex. Node 1
$ cockroach start --insecure --listen-addr=localhost:26257 \
>   --join=localhost:26257,localhost:26258,localhost:26259 \
>   --http-addr=localhost:8080 --store=cockroach-data-1 --background
*
* WARNING: ALL SECURITY CONTROLS HAVE BEEN DISABLED!
*
* This mode is intended for non-production testing only.
*
* In this mode:
* - Your cluster is open to any client that can access localhost.
* - Intruders with access to your machine or network can observe client-server traffic.
* - Intruders can log in without password and read or write any data in the cluster.
* - Intruders can consume all your server's resources and cause unavailability.
*
*
* INFO: To start a secure server without mandating TLS for clients,
* consider --accept-sql-without-tls instead. For other options, see:
*
* - https://go.crdb.dev/issue-v/53404/v25.4
* - https://www.cockroachlabs.com/docs/v25.4/secure-a-cluster.html
*
*
* WARNING: Running a server without --sql-addr, with a combined RPC/SQL listener, is deprecated.
* This feature will be removed in a later version of CockroachDB.
*
*
* INFO: initial startup completed.
* Node will now attempt to join a running cluster, or wait for `cockroach init`.
* Client connections will be accepted after this completes successfully.
* Check the log file(s) for progress.


To create the other nodes just create each node with the same command with the porper changes.
Ex. Node 2:
$ cockroach start --insecure --listen-addr=localhost:26258   --join=localhost:26257,localhost:26258,localhost:26259   --http-addr=localhost:8081 --store=cockroach-data-2 --background

Ex. Node 3:
$ cockroach start --insecure --listen-addr=localhost:26259   --join=localhost:26257,localhost:26258,localhost:26259   --http-addr=localhost:8082 --store=cockroach-data-3 --background

Ex. Node 4:
$ cockroach start --insecure --listen-addr=localhost:26260 --join=localhost:26257,localhost:26258,localhost:26259,localhost:26260,localhost:26261 --http-addr=localhost:8083 --store=cockroach-data-4 --background

Ex. Node 5:
$ cockroach start --insecure --listen-addr=localhost:26261 --join=localhost:26257,localhost:26258,localhost:26259,localhost:26260,localhost:26261 --http-addr=localhost:8084 --store=cockroach-data-5 --background


After you have created all nodes you need to initalize the cluster with the following command:

$ cockroach init --host localhost:26258 --insecure


To open from the terminal the UI you can run the following command:

$ open http://localhost:8080



------------Fault Tolerance and Automated Recovery---------------------

---- Connection string ------------
Why does the connection string begin with postgresql?
SQL queries reach your cluster through the PostgreSQL wire protocol. This makes connecting your application to the cluster simple by supporting many PostgreSQL-compatible drivers and ORMs.

----- When a Node is Down  ----------
What first occurs automatically when a node is suspected of being down?
By default, the cluster waits 5 minutes before considering the node dead.


---------------------Localities-----------------------------------------
In a distributed cluster, it's important to understand where nodes are located to increase resiliency and mitigate unnecessary latency.
When starting a node with a cockroach start command, you can use the locality flag to assign arbitrary key value pairs that described the location of the node.
Ex.
$ cockroach start --insecure --locality=country=us,region=us-east --store=node1 --listen-addr=localhost:26257 --http-addr=localhost:8080 
--join=localhost:26257,localhost:26258,localhost:26259 --background

Locality flag:
--locality=country=us,region=us-east

An example of a cluster with multiple nodes with multiple locations, commands are as follow:
$ cockroach start --insecure --locality=country=us,region=us-east --store=node1 --listen-addr=localhost:26257 --http-addr=localhost:8080 --join=localhost:26257,localhost:26258,localhost:26259 --background

$ cockroach start --insecure --locality=country=us,region=us-east --store=node2 --listen-addr=localhost:26258 --http-addr=localhost:8081 --join=localhost:26257,localhost:26258,localhost:26259 --background

$ cockroach start --insecure --locality=country=us,region=us-east --store=node3 --listen-addr=localhost:26259 --http-addr=localhost:8082 --join=localhost:26257,localhost:26258,localhost:26259 --background

$ cockroach start --insecure --locality=country=us,region=us-central --store=node4 --listen-addr=localhost:26260 --http-addr=localhost:8083 --join=localhost:26257,localhost:26258,localhost:26259 --background

$ cockroach start --insecure --locality=country=us,region=us-central --store=node5 --listen-addr=localhost:26261 --http-addr=localhost:8084 --join=localhost:26257,localhost:26258,localhost:26259 --background

$ cockroach start --insecure --locality=country=us,region=us-central --store=node6 --listen-addr=localhost:26262 --http-addr=localhost:8085 --join=localhost:26257,localhost:26258,localhost:26259 --background

$ cockroach start --insecure --locality=country=us,region=us-west --store=node7 --listen-addr=localhost:26263 --http-addr=localhost:8086 --join=localhost:26257,localhost:26258,localhost:26259 --background

$ cockroach start --insecure --locality=country=us,region=us-west --store=node8 --listen-addr=localhost:26264 --http-addr=localhost:8087 --join=localhost:26257,localhost:26258,localhost:26259 --background

$ cockroach start --insecure --locality=country=us,region=us-west --store=node9 --listen-addr=localhost:26265 --http-addr=localhost:8088 --join=localhost:26257,localhost:26258,localhost:26259 --background

$ cockroach init --insecure --host=localhost:26257

To find out where are the ranges located on you can use the SHOW RANGES command:
cockroach sql --insecure --host=localhost:26257 --execute="SHOW RANGES FROM TABLE <databse.table>;"
 Ex.
cockroach sql --insecure --host=localhost:26257 --execute="SHOW RANGES FROM TABLE movr.users;"
This command will the "replica_localities" for the ranges of the table you specified in the command.
